#using STLImportExport.*
#using AttrCondDefLibrary.*

#rule EdgeRule #with STLImportExport

#source { 
	
	s:Solid{
		++-facets->facet1
	}
	
	
    ++ facet1:myDsl.Facet{
    	++ -normal->n
        ++ -v1-> vec1
        ++ -v2-> vec2
        ++ -v3-> vec3
        
    }
    
    ++ vec1:myDsl.Vector
    ++ vec2:myDsl.Vector
    ++ vec3:myDsl.Vector
    ++ n:myDsl.Normalvector
    
}

#target {
	
	solid:Solid{
		++-facets->facet2
	}
	
    ++ facet2:Metamodell.Facet {
    	++-normal->normal
        ++-edges->e1
        ++-edges->e2
        ++-edges->e3
    }
    
    ++normal:Metamodell.Vector3f
    
    ++ e1:Metamodell.Edge{
    	++-f->facet2
        ++-a->a1
        ++-b->b1
    }
    

    ++ e2:Metamodell.Edge{
    	++-f->facet2
        ++-a->b1
        ++-b->c1
    }
    
    ++ e3:Metamodell.Edge{
    	++-f->facet2
        ++-a->c1
        ++-b->a1
    }
    
    
    ++a1:Metamodell.Vector3f{
    	
    }
    ++b1:Metamodell.Vector3f
    ++c1:Metamodell.Vector3f
    
}

#correspondence {
    ++v1v:VectorToVector{
        #src->vec1
        #trg->a1        
        
    }
    
    ++v2v:VectorToVector{
        #src->vec2
        #trg->b1
    }
    
    ++v3v:VectorToVector{
        #src->vec3
        #trg->c1
        
    }
    
    ++n2n:NormalToNormal{
    	#src->n
    	#trg->normal
    }
}

#attributeConditions {
    
   eq_float(vec1.x1,a1.x)
   eq_float(vec1.x2,a1.y)
   eq_float(vec1.x3,a1.z)
   
   eq_float(vec2.x1,b1.x)
   eq_float(vec2.x2,b1.y)
   eq_float(vec2.x3,b1.z)
   
   eq_float(vec1.x1,c1.x)
   eq_float(vec1.x2,c1.y)
   eq_float(vec1.x3,c1.z)
}

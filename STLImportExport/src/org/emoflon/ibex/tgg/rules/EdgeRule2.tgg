#using STLImportExport.*
#using AttrCondDefLibrary.*

#rule EdgeRule2 #with STLImportExport

#source { 
	
	++facet:myDsl.Facet{
		++-v1->vector1
		++-v2->vector2
		++-v3->vector3

	}
	
	vector1:myDsl.Vector
	vector2:myDsl.Vector
	vector3:myDsl.Vector
	
}

#target {
	
	++edge2:Metamodell.Edge{
		++-f->fac
		++-a->b1
		++-b->c1
		
	}
	
	
	++edge3:Metamodell.Edge{
		++-f->fac
		++-a->a1
		++-b->c1
		
	}
	
	
	edge:Metamodell.Edge{
		-a->a1
		-b->b1
		++-f->fac	
			
		}
		
					
		
		
	
		++fac:Metamodell.Facet{
			++-edges->edge
			++-edges->edge2
			++-edges->edge3
		}
		
	  a1:Metamodell.Vector3f    
   	  b1:Metamodell.Vector3f
      c1:Metamodell.Vector3f
			
	}

#correspondence {
	++f2f:FacetToFacet{
		#src->facet
		#trg->fac
	}	
	
	v2v:VectorToVector{
		#src->vector1
		#trg->a1
	}
		
	
 	v3v:VectorToVector{
		#src->vector2
		#trg->b1
	}
	
	++v4v:VectorToVector{
		#src->vector3
		#trg->c1
	}
	
}

#attributeConditions {
 
   eq_float(vector1.x1,a1.x)
   eq_float(vector1.x2,a1.y)
   eq_float(vector1.x3,a1.z)
   
   eq_float(vector2.x1,b1.x)
   eq_float(vector2.x2,b1.y)
   eq_float(vector2.x3,b1.z)
   
   eq_float(vector3.x1,c1.x)
   eq_float(vector3.x2,c1.y)
   eq_float(vector3.x3,c1.z)
	
	
}
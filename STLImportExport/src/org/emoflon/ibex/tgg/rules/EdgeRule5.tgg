#using STLImportExport.*
#using AttrCondDefLibrary.*

#rule EdgeRule5 #with STLImportExport


#source { 
	
	s:Solid{
		++-facets->facet1
	}
	
	
    ++ facet1:myDsl.Facet{
    	++ -normal->n
        ++ -v1-> vec1
        ++ -v2-> vec2
        ++ -v3-> vec3
    }
    
      vec1:myDsl.Vector
      vec2:myDsl.Vector
      vec3:myDsl.Vector
    ++ n:myDsl.Normalvector
    
}

#target {
	
	solid:Solid{
		++-facets->facet2
	}
	
    ++ facet2:Metamodell.Facet {
    	++-normal->normal
        ++-edges->e1
        ++-edges->e2
        ++-edges->e3
        ++-solid->solid
    }
    
    ++normal:Metamodell.Vector3f
    
     e1:Metamodell.Edge{
    	++-f->facet2
        -p->a1
        -p->b1
        -f->_facet3
    }
    

     e2:Metamodell.Edge{
    	++-f->facet2
        -p->b1        
       	-p->c1
       	-f->_facet4
    }
    
    ++ e3:Metamodell.Edge{
    	++-f->facet2
        ++-p->c1
        ++-p->a1
    }
    
    _facet3:Metamodell.Facet
    _facet4:Metamodell.Facet
    a1:Metamodell.Vector3f    
    b1:Metamodell.Vector3f
    c1:Metamodell.Vector3f
    
}

#correspondence {
    ++v1v:VectorToVector{
        #src->vec1
        #trg->a1        
        
    }
    
    ++v2v:VectorToVector{
        #src->vec2
        #trg->b1
    }
    
    ++v3v:VectorToVector{
        #src->vec3
        #trg->c1
        
    }
    
    ++n2n:NormalToNormal{
    	#src->n
    	#trg->normal
    }
}

#attributeConditions {
    
   eq_float(vec1.x1,a1.x)
   eq_float(vec1.x2,a1.y)
   eq_float(vec1.x3,a1.z)
   
   eq_float(vec2.x1,b1.x)
   eq_float(vec2.x2,b1.y)
   eq_float(vec2.x3,b1.z)
   
   eq_float(vec3.x1,c1.x)
   eq_float(vec3.x2,c1.y)
   eq_float(vec3.x3,c1.z)
   
   eq_float(n.x1,normal.x)
   eq_float(n.x2,normal.y)
   eq_float(n.x3,normal.z)
}